<html>
  <head>
    <title>Three.js Crash</title>

    <style>
      body {
        width: 100%;
        height: 100%;
        background-color: rgba(1, 1, 1, 1);
      }
      #overlay {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: rgba(1, 0, 0, 0.5);
      }
      #pause {
        width: 100%;
        height: 100%;

        display: -webkit-box;
        display: -moz-box;
        display: box;

        -webkit-box-orient: horizontal;
        -moz-box-orient: horizontal;
        box-orient: horizontal;

        -webkit-box-pack: center;
        -moz-box-pack: center;
        box-pack: center;

        -webkit-box-align: center;
        -moz-box-align: center;
        box-align: center;

        color: #ffffff;
        text-align: center;

        cursor: pointer;
      }
    </style>
  </head>

  <body>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/PointerLockControls.js"></script>
    <script src="js/OBJLoader.js"></script>
    <script src="js/MTLLoader.js"></script>
    <script src="js/ColladaLoader.js"></script>
    <script src="js/enemy.js"></script>

    <script>
      /*

    <div id="overlay">
      <div id="pause">
        <span style="font-size:30px">PAUSE</span>
      </div>
    </div>
      var scene, camera, controls, renderer;
      var objects = [];
      var enemy;

      var raycaster;

      var overlay = document.getElementById('overlay');
      var pause = document.getElementById('pause');

      var pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

      if(pointerLock) {
        var element = document.body;

        var pointerLockChange = function (event) {
          if(document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
            enableControls = true;
            controls.enabled = true;
            overlay.style.display = 'none';
          } else {
            controls.enabled = false;
            overlay.style.display = 'block';
            pause.style.display = '';
          }
        };

        var pointerLockError = function (event) {
          pause.style.display = '';
        }

        var pauseClickEvent = function (event) {
          pause.style.display = 'none';
          element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
          element.requestPointerLock();
        }

        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', pointerLockChange, false);

        document.addEventListener('pointerlockerror', pointerLockError, false);
        document.addEventListener('mozpointerlockerror', pointerLockError, false);
        document.addEventListener('webkitpointerlockerror', pointerLockError, false);

        pause.addEventListener('click', pauseClickEvent, false);
      } else {
        pause.innerHTML = 'Browser does not support Pointer Lock API';
      }

      var enableControls = false;
      var move_forward = false;
      var move_backward = false;
      var move_left = false;
      var move_right = false;
      var move_jump = false;

      var lastTime = performance.now();
      var velocity = new THREE.Vector3();
      var direction = new THREE.Vector3();
      var vertex = new THREE.Vector3();
      var color = new THREE.Color();

      start();
      update();

      function start() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
        light.position.set(0.5, 1, 0.75);
        scene.add(light);

        // --- Controls --- //
        controls = new THREE.PointerLockControls(camera);
        scene.add(controls.getObject());

        var onKeyDown = function(event) {
          switch(event.keyCode) {
            case 87: move_forward = true; break;
            case 83: move_backward = true; break;
            case 65: move_left = true; break;
            case 68: move_right = true; break;
            case 32: if(move_jump) velocity.y += 75; move_jump = false; break;
          }
        };

        var onKeyUp = function(event) {
          switch(event.keyCode) {
            case 87: move_forward = false; break;
            case 83: move_backward = false; break;
            case 65: move_left = false; break;
            case 68: move_right = false; break;
          }
        };

        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        // ---------------- //

        raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 5);

        // --- Floor Object --- //
        var floorGeometry = new THREE.PlaneBufferGeometry(100, 100, 10, 10);
        floorGeometry.rotateX(-Math.PI / 2);

        var position = floorGeometry.attributes.position;
        for(var i = 0; i < position.count; i++) {
          vertex.fromBufferAttribute(position, i);
          vertex.x += Math.random() * 2 - 1;
          vertex.y += Math.random();
          vertex.z += Math.random() * 2 - 1;
          position.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
        floorGeometry = floorGeometry.toNonIndexed();

        count = floorGeometry.attributes.position.count;
        colors = [];
        for(var i = 0; i < count; i++) {
          color.setHSL(1, 0, Math.random() * 0.4 + 0.6);
          colors.push(color.r, color.g, color.b);
        }
        floorGeometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        var floorMaterial = new THREE.MeshBasicMaterial({vertexColors: THREE.VertexColors});
        var floor = new THREE.Mesh(floorGeometry, floorMaterial);
        scene.add(floor);
        // -------------------- //

        // --- Box Object --- //
        var boxGeometry = new THREE.BoxBufferGeometry(10, 10, 10);
        boxGeometry = boxGeometry.toNonIndexed();

        count = boxGeometry.attributes.position.count;
        colors = [];
        for (var i = 0; i < count; i++) {
          color.setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
          colors.push(color.r, color.g, color.b);
        }
        boxGeometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        for (var i = 0; i < 10; i++) {
          var boxMaterial = new THREE.MeshPhongMaterial({specular: 0xffffff, flatShading: true, vertexColors: THREE.VertexColors});
          boxMaterial.color.setHSL(Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
          var box = new THREE.Mesh(boxGeometry, boxMaterial);
          box.position.x = Math.floor(Math.random() * 10 - 5) * 10;
          box.position.y = 5;
          box.position.z = Math.floor(Math.random() * 10 - 5) * 10;
          scene.add(box);
          objects.push(box);
        }
        // ------------------ //

        // --- Enemy Object --- //
        enemy = new THREE.EnemyPrefab(scene, 5);
        // -------------------- //

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        var onWindowResize = function(event) {
          var width = window.innerWidth;
          var height = window.innerHeight;
          renderer.setSize(width, height);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
        };

        window.addEventListener('resize', onWindowResize, false);
      }

      function update() {
        requestAnimationFrame(update);

        if(enableControls) {
          //var controlObject = controls.getObject();
          var controlObject = enemy.enemyPrefab;

          raycaster.ray.origin.copy(controlObject.position);

          var intersections = raycaster.intersectObjects(objects);
          var onObject = intersections.length > 0;

          var time = performance.now();
          var deltaTime = (time - lastTime) / 1000;

          velocity.x *= 1 - 10.0 * deltaTime;
          velocity.z *= 1 - 10.0 * deltaTime;
          velocity.y -= 9.8 * 25.0 * deltaTime;

          direction.z = Number(move_forward) - Number(move_backward);
          direction.x = Number(move_left) - Number(move_right);
          direction.normalize();

          if(move_forward || move_backward) velocity.z -= direction.z * 400.0 * deltaTime;
          if(move_left || move_right) velocity.x -= direction.x * 400.0 * deltaTime;

          if(onObject) {
            velocity.y = Math.max(0, velocity.y);
            move_jump = true;
          }

          controlObject.translateX(velocity.x * deltaTime);
          controlObject.translateY(velocity.y * deltaTime);
          controlObject.translateZ(velocity.z * deltaTime);

          if(controlObject.position.y < 5) {
            velocity.y = 0;
            controlObject.position.y = 5;
            move_jump = true;
          }

          lastTime = time;
        }

        renderer.render(scene, camera);
      }
      */




      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', function() {
        var width = window.innerWidth;
        var height = window.innerHeight;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      });

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      //controls = new THREE.FirstPersonControls(camera, renderer.domElement);

      var loadingManager = new THREE.LoadingManager(function() {
        scene.add(gunModel);
      });

      var loader = new THREE.ColladaLoader(loadingManager);
      loader.load('./models/gun.dae', function (collada) {
        gunModel = collada.scene;
      });

      //var enemy = new THREE.EnemyPrefab(scene);

      camera.position.z = 3;

      var update = function() {
        
        //cube.rotation.x += 0.01;
        //cube.rotation.y += 0.005;
        
        //enemy.setGeometry();
      };

      var render = function() {
        renderer.render(scene, camera);
      };

      var GameLoop = function() {
        requestAnimationFrame(GameLoop);

        update();
        render();
      };

      GameLoop();
    </script>
  </body>
</html>